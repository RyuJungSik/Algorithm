# 브루트포스

# 브루트 포스

- 4자리수 비밀번호면 → 0000~9999까지 확인하는 것
- 부르트포스의 3단계
    - 문제의 가능한 경우의 수를 계산해본다.
    - 가능한 모든 방법을 다 만들어본다.
        - for, 순열, **재귀 호출**, 비트마스크
    - 각각의 방법을 이용해 답을 구해본다.

## 기본 브루트 포스

- 2중 ,3중 포문으로 구현
- 중복된 값, 불필요한 값은 제거하는 것이 유리.
EX) 리모콘은 숫자 버튼 후  방향 버튼이 최소임.
- 모든 경우 다해보기
EX) 테트로미노 19가지 경우 전부 고려함.
- 경우가 너무 많은경우 특정 조건만 건너 띄면서 고려
EX) 카잉 달력에서 모든해가 아닌 i*M+x만 고려.
- 2차원 배열은 (r,c)를 r*m+c로 나타낼 수 있다.

## 재귀와 백트래킹

- 백트래킹 → 더이상 호출이 의미없으면 재귀를 중단시킨다.
- 백트래킹
EX) 부호로 값을  찾는경우 각 수마다 경우가 다르면 재귀 중단.

## 순열

- 파이썬은 itertools의 permutation사용가능
- 다음순열 구하기.
    - 맨오르쪽부터 a[i-1]<a[i]인 i를 찾는다.
    → 즉 왼쪽이 오른쪽보다 작아지는 자리를 찾는다.\
    - 맨 오른쪽부터 a[j] >a[i-1]를 만족하는 가장 큰 j 찾는다.
    오른쪽에서 부터 j가 i-1보다 커지는 순간을 찾는다.
    - a[i-1]과 a[j]를 swap한다.
    - a[i]부터 순열을 reverse한다.
    
    ```python
    def next_permutation(a):
    	#i와 i-1찾기
    	i=len(a)-1
    	while i>0 and a[i-1] >= a[i]:
    		i-=1
    	if i<=0: #마지막 순열인 경우다.
    		return False
    	#j 찾기
    	j=len(a)-1
    	while a[j] <=a[i-1]:
    		j-=1
    
    	#j자리수와 i-1자리수 스왑
    	a[i-1], a[j] = a[j], a[i-1]
    
    	#i~j수열 리버스
    	while i<j:
    		a[i],a[j]=a[j],a[i]
    		i+=1
    		j-=1	
    	return True
    ```
    

## 비트마스크

- 비트마스크 종류
    - & → and
    - | → or
    - ~ → not
    - ^ → xor
    - a<<b → 왼쪽으로 b만큼 이동. 2제곱하는꼴
    - a>>b → 오른쪽으로 b 만큼 이동, 2제곱 나누기와 동일
- 숫자도 비트로 이루어져 있다.
- 브루트 포스에서 비트마스크 사용법
- 장점 → 정수이므로 모든 연산이 1, 공간이 적음
단점 → 배열이 더 편한다.

```python
for s in range(1<<4):
	pass

#이렇게하면
# 0000,0001,0010~1111까지 총16가지 경우 검사가능
```